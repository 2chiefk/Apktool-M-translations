<?xml version="1.0" encoding="utf-8"?>
<resources>
	<string-array name="smali_help_names">
		<item>רושמים</item>
		<item>ערכים מילוליים</item>
		<item>סוגי נתונים פרימיטיביים</item>
	</string-array>
	<string-array name="smali_help_values" formatted="false">
		<item>vA הוא אוגר של 4 סיביות עם טווח הערכים v0 - v15\nvAA הוא אוגר של 8 סיביות עם טווח ערכים של v0 - v255\nvAAAA הוא אוגר של 16 סיביות עם טווח ערכים של v0 - v65535</item>
		<item>נעשה שימוש ב-0xF, 0xFF וכו\'. לייצג ערכים מילוליים. כמו רגיסטרים, המספר F משמש לייצוג טווח של ערכים, לדוגמה:\nהטווח של ערכי 0xF מיוצג על ידי [-0x8, 0x7]\nטווח הערכים של 0xFF מיוצג על ידי [-0x80, 0x7F]</item>
		<item>V - ריק, Z - בוליאני, B - בייט\nC - char, S - קצר, I - int\nJ - ארוך, F - לצוף, D - כפול\nvoid: ניתן להשתמש רק עבור סוגי החזרות\nboolean: מאחסן את הערך true או false\nbyte: מאחסן מספר שלם מ-128 עד 127 ותופס בית אחד\nקצר: מאחסן מספר שלם מ-32768 עד 32767 ולוקח 2 בתים\nint: מאחסן מספר שלם מ-2147483648 עד 2147483647 ותופס 4 בתים\nארוך: מאחסן מספר שלם מ-9223372036854775808 עד 9223372036854775807 ותופס 8 בתים\nכפול: מאחסן מספר נקודה צפה מ-±4.9*10³²⁴ עד ±1.7976931348623157*10³⁰⁸ ותופס 8 בתים. נקודה משמשת כמפריד עשרוני במילולי שבר.\nfloat: מאחסן מספר נקודה צפה מ-3.4*10³⁸ עד 3.4*10³⁸ ותופס 4 בתים\nchar: מאחסן תו בודד בקידוד UTF-16 ותופס 2 בתים, כך שטווח הערכים המאוחסנים הוא מ-0 עד 65535.</item>
		<item>שום פעולה.</item>
		<item>מעביר את הערך של register vB ל- register vA.</item>
		<item>מעביר את הערך של אוגר vBBBB לאוגר vAA.</item>
		<item>מעביר את הערך של האוגר vBBBB לאוגר vAAAA.</item>
		<item>מעביר את הערך הארוך/כפול של זוג אוגר (vB, vB+1) לזוג רישום vA, vA+1.</item>
		<item>מעביר את הערך הארוך/כפול של זוג אוגר (vBBBB, vBBBB+1) לזוג אוגר vAA, vAA+1.</item>
		<item>מעביר את הערך הארוך/כפול של זוג אוגר (vBBBB, vBBBB+1) לזוג אוגר vAAAA, vAAAA+1.</item>
		<item>מעביר הפניה לאובייקט מהאוגר של vB לאוגר vA.</item>
		<item>מעביר הפניה לאובייקט מהאוגר של vBBBB לאוגר vAA.</item>
		<item>מעביר הפניה לאובייקט מהאוגר vBBBB לאוגר vAAAA.</item>
		<item>מעביר את ערך ההחזרה של השיטה שנקראה בעבר לתוך אוגר vAA.</item>
		<item>מעביר את הערך הארוך/כפול שהוחזר על ידי השיטה שנקראה קודם לזוג האוגר vAA, vAA+1.</item>
		<item>מעביר את הפניה לאובייקט שהוחזרה על ידי השיטה שנקראה בעבר לתוך האוגר vAA.</item>
		<item>מעביר את ההפניה לאובייקט הבלתי נכלל שהופק במהלך קריאת השיטה (במהלך ביצוע) ל-vAA register.</item>
		<item>החזר ללא ערך החזרה.</item>
		<item>החזר על ידי החזרת הערך מאוגר vAA.</item>
		<item>החזר על ידי החזרת ערך כפול/ארוך לזוג אוגרים vAA, vAA+1.</item>
		<item>החזר על ידי החזרת הערך של הפניה לאובייקט מהאוגר של vAA.</item>
		<item>מציב קבוע של 4 סיביות לתוך האוגר vA.</item>
		<item>מציב קבוע של 16 סיביות לתוך האוגר vAA.</item>
		<item>מציב קבוע מספר שלם לתוך האוגר vAA.</item>
		<item>מציב קבוע של 16 סיביות בסיביות העליונות של האוגר vAA. משמש לאתחול ערכי ציפה (נקודה צפה).</item>
		<item>מציב קבוע מספר שלם של 16 סיביות לתוך זוג האוגר vAA, vAA+1, וממיר את קבוע המספר השלם לקבוע ארוך.</item>
		<item>מציב קבוע מספר שלם של 32 סיביות לתוך זוג האוגר vAA, vAA+1, וממיר את קבוע המספר השלם לקבוע ארוך.</item>
		<item>מציב קבוע של 64 סיביות לתוך זוג האוגר vAA, vAA+1.</item>
		<item>מציב קבוע של 16 סיביות לתוך 16 הסיביות העליונות של זוג האוגר vAA, vAA+1. משמש לאתחול ערכים כפולים (נקודה צפה).</item>
		<item>מציב הפניה למחרוזת שצוינה באוגר vAA.</item>
		<item>מציב הפניה למחרוזת שצוינה באוגר vAA.</item>
		<item>מציב הפניה לקבוע המחרוזת (מחרוזת) המזוהה על ידי string_id לתוך האוגר vAA.</item>
		<item>מקבל את מוניטור האובייקטים שמתייחסים אליו על ידי האוגר vAA.</item>
		<item>משחרר את צג האובייקטים שאליו מתייחס אוגר vAA.</item>
		<item>בודק האם ניתן להטיל הפניה לאובייקט הכלול ב-vAA למחלקה המזוהה על ידי type_id. זורק ClassCastException אם הוא לא יכול, אחרת ממשיך בביצוע.</item>
		<item>בודק אם התוכן של אוגר vB הוא מופע של המחלקה המזוהה על ידי type_id. מגדיר את ה-vA של הרישום ללא אפס אם קיים, 0 אם לא.\nvA = vB instanceOf type ? 10</item>
		<item>קובע את מספר רכיבי המערך מאוגר vB וממקם את הערך באוגר vA.\nvA = vB.length</item>
		<item>יוצר מופע של סוג אובייקט ומציב הפניה למופע שנוצר במאגר vAA.</item>
		<item>יוצר מערך חדש של משתני type_id בגודל של רכיבי register vB ומציב הפניה למערך ב- register vA.</item>
		<item>יוצר מערך נתונים חדש מסוג type_id וממלא אותו בפרמטרים (כלומר, אין מערכים ארוכים/כפולים, אך מותרים סוגי הפניות). ניתן לקבל התייחסות למערך החדש שנוצר באמצעות הצהרת move-result-object מיד לאחר הצהרה זו (אם יש להשתמש באחת כזו).</item>
		<item>יוצר מערך נתונים חדש מסוג type_id וממלא אותו בטווח של פרמטרים (כלומר, אין מערכים ארוכים/כפולים, אבל סוגי הפניות מקובלים). ניתן לקבל התייחסות למערך החדש שנוצר באמצעות הצהרת move-result-object מיד לאחר הצהרה זו (אם יש להשתמש באחת כזו).</item>
		<item>ממלא את המערך שאליו מתייחסים ברישום vAA בנתונים סטטיים. מיקום הנתונים הוא סכום המיקום של ההוראה הנוכחית וההיסט.</item>
		<item>זורק חפץ חריג. הפניה לאובייקט החריג בפנקס vAA.</item>
		<item>קפוץ ללא תנאי לקיזוז קצר (מספר שלם) של 8 סיביות.</item>
		<item>קפיצה בלתי מותנית להיסט של 16 סיביות.</item>
		<item>קפיצה בלתי מותנית להיסט של 32 סיביות.</item>
		<item>מיישמת אופרטור Switch כאשר קבועי הבקרה קרובים זה לזה (ברצף). ההוראה משתמשת בטבלת אינדקס. קיזוז ההוראה למקרה מסוים נקבע על ידי מדד vAA. אם אינדקס vAA חורג מהטבלה, הביצוע ממשיך עם ההצהרה הבאה (ברירת מחדל).</item>
		<item>מיישמת אופרטור Switch במקרה של טבלה דלילה. ההוראה משתמשת בטבלה המציינת קיזוזים עבור כל קבוע. אם לא נמצאו התאמות בטבלה, ההצהרה הבאה מבוצעת (אות ברירת מחדל).</item>
		<item>משווה את ערכי הציפה (הנקודה הצפה) ב-vBB ו-vCC וממקם את הערך השלם במאגר vAA:\nvAA = vBB &lt; vCC ? כן: 1, לא: -1, שווה: 0</item>
		<item>משווה את ערכי הציפה (הנקודה הצפה) ב-vBB ו-vCC וממקם את הערך השלם במאגר vAA:\nvAA = vBB &lt; vCC ? כן: 1, לא: -1, שווה: 0</item>
		<item>משווה את הערכים הכפולים (הנקודה צפה) ב-vBB ו-vCC וממקם את הערך השלם באוגר vAA:\nvAA = (vBB, vBB+1) &lt; (vCC, vCC+1) ? y\nכן: 1, לא: -1, שווה: 0</item>
		<item>משווה את הערכים הכפולים (הנקודה צפה) ב-vBB ו-vCC וממקם את הערך השלם באוגר vAA:\nvAA = (vBB, vBB+1) > (vCC, vCC+1) ? כן: 1, לא: -1, שווה: 0</item>
		<item>משווה את הערכים הארוכים (המספר השלם) ב-vBB וב-vCC וממקם את הערך השלם (השלם) במאגר vAA:\nvAA = (vBB, vBB+1) > (vCC, vCC+1) ? כן: 1, לא: -1, שווה: 0</item>
		<item>קופץ לתווית שצוינה אם vA == vB. vA ו-vB מכילים ערכים שלמים.\n(eq הוא קיצור של Equals)</item>
		<item>קופץ לתווית שצוינה אם vA != vB. vA ו-vB מכילים ערכים שלמים.\n(ne הוא קיצור של לא שווה)</item>
		<item>קופץ לתווית שצוינה אם vA &lt; vB. vA ו-vB מכילים ערכים שלמים.\n(זה קיצור של פחות מ)</item>
		<item>קופץ לתווית שצוינה אם vA &lt;= vB. vA ו-vB מכילים ערכים שלמים.\n(le הוא קיצור של פחות או שווה/פחות או שווה)</item>
		<item>קופץ לתווית שצוינה אם vA > vB. vA ו-vB מכילים ערכים שלמים.\n(gt הוא קיצור של Greater Than/More Than)</item>
		<item>קופץ לתווית שצוינה אם vA >= vB. vA ו-vB מכילים ערכים שלמים.\n(ge הוא קיצור של Greater than או Equal)</item>
		<item>קופץ לתווית שצוינה אם vAA == 0. vAA מכיל ערך שלם.\n(eqz הוא קיצור של שווה לאפס)</item>
		<item>קופץ לתווית שצוינה אם vAA != 0. vAA מכיל ערך שלם.\n(nez הוא קיצור של לא שווה לאפס)</item>
		<item>קופץ לתווית שצוינה אם vAA &lt; 0. vAA מכיל ערך שלם.\n(ltz הוא קיצור של Less Than Zero)</item>
		<item>קופץ לתווית שצוינה אם vAA &lt;= 0. vAA מכיל ערך שלם.\n(lez הוא קיצור של פחות מ או שווה לאפס/פחות או שווה לאפס)</item>
		<item>קופץ לתווית שצוינה אם vAA > 0. vAA מכיל ערך שלם.\n(gtz הוא קיצור של Greater Than Zero)</item>
		<item>קופץ לתווית שצוינה אם vAA >= 0. vAA מכיל ערך שלם.\n(gez הוא קיצור של גדול מ- או שווה לאפס)</item>
		<item>מקבל ערך מספר שלם באינדקס הכלול ב-vCC מהמערך שאליו מתייחס vBB וממקם אותו במאגר vAA.\nvAA = vBB[vCC]</item>
		<item>מקבל, באינדקס הכלול ב-vCC, מהמערך שאליו מתייחס vBB, ערך כפול/ארוך וממקם אותו בזוג האוגר vAA, vAA+1.\n(vAA, vAA+1) = vBB[vCC]</item>
		<item>מקבל, באינדקס הכלול ב-vCC, מהמערך שאליו מתייחס vBB, הפניה לאובייקט וממקם אותו במאגר vAA.\nvAA = vBB[vCC]</item>
		<item>מקבל, באינדקס הכלול ב-vCC, מהמערך שאליו יש הפניה ב-vBB, ערך בוליאני וממקם אותו במאגר vAA.\nvAA = vBB[vCC]</item>
		<item>שואב, באינדקס הכלול ב-vCC, מהמערך שאליו מתייחס vBB, ערך בתים (מספר שלם) וממקם אותו במאגר vAA.\nvAA = vBB[vCC]</item>
		<item>שואב, באינדקס הכלול ב-vCC, מהמערך שאליו מתייחס vBB, ערך char וממקם אותו במאגר vAA.\nvAA = vBB[vCC]</item>
		<item>שואב, באינדקס הכלול ב-vCC, מהמערך שאליו מתייחס vBB, ערך קצר (מספר שלם) וממקם אותו במאגר vAA.\nvAA = vBB[vCC]</item>
		<item>ממקם את הערך השלם מ-vAA לתוך המערך שאליו מתייחס vBB עם האלמנט המכיל את האוגר vCC.\nvBB[vCC] = vAA</item>
		<item>מציב ערך כפול/ארוך מצמד האוגר vAA, vAA+1 לתוך המערך שאליו מתייחס vBB, כאשר האלמנט מכיל את האוגר vCC.\nvBB[vCC] = (vAA, vAA+1)</item>
		<item>ממקמת הפניה לאובייקט מ-vAA לתוך המערך שאליו מתייחס vBB עם אלמנט עם האוגר vCC.\nvBB[vCC] = vAA</item>
		<item>ממקם את הערך הבוליאני מ-vAA לתוך המערך שאליו מתייחס vBB עם האלמנט המכיל את האוגר vCC.\nvBB[vCC] = vAA</item>
		<item>ממקם את ערך הבתים (המספר השלם) מ-vAA לתוך המערך שאליו מתייחס vBB עם האלמנט המכיל את האוגר vCC.\nvBB[vCC] = vAA</item>
		<item>ממקם את ערך התו (תו) מ-vAA לתוך המערך שאליו מתייחס vBB לפי אלמנט עם register vCC.\nvBB[vCC] = vAA</item>
		<item>ממקם את הערך הקצר (המספר השלם) מ-vAA לתוך המערך שאליו מתייחס vBB עם האלמנט המכיל את אוגר vCC.\nvBB[vCC] = vAA</item>
		<item>קורא את הערך משדה המופע וממקם אותו במאגר vA. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvA = vB.field</item>
		<item>קורא ערך כפול/ארוך משדה מופע וממקם אותו בזוג אוגרים (vA, vA+1). ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\n(vA, vA+1) = vB.field</item>
		<item>קורא הפניה לאובייקט משדה מופע וממקם אותו במאגר vA. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvA = vB.field</item>
		<item>קורא ערך בוליאני משדה המופע וממקם אותו במאגר vA. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvA = vB.field</item>
		<item>קורא ערך בתים (מספר שלם) משדה מופע וממקם אותו במאגר vA. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvA = vB.field</item>
		<item>קורא ערך char משדה מופע וממקם אותו במאגר vA. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvA = vB.field</item>
		<item>קורא ערך קצר (מספר שלם) משדה מופע וממקם אותו במאגר vA. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvA = vB.field</item>
		<item>ממקם את הערך מאוגר ה-vA בשדה המופע. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvB.field = vA</item>
		<item>מציב ערך כפול/ארוך מזוג אוגר (vA, vA+1) לתוך שדה מופע. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvB.field = (vA, vA+1)</item>
		<item>ממקמת הפניה לאובייקט מאוגר ה-vA בשדה המופע. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvB.field = vA</item>
		<item>ממקם את הערך הבוליאני מאוגר ה-vA בשדה המופע. ההתייחסות למחלקה המכילה את השדה הזה נמצאת ברישום vB.\nvB.field = vA</item>
		<item>מגדיר את ערך הבתים (מספר שלם) של השדה הבוליאני שצוין במופע שאליו מתייחס register vB שווה לערך של register vA, כלומר:\nvB.field = vA</item>
		<item>מגדיר את ערך התו (תו) של השדה הבוליאני שצוין במופע שאליו מתייחס register vB שווה לערך של register vA, כלומר:\nvB.field = vA</item>
		<item>מגדיר את הערך הקצר (המספר השלם) של השדה הבוליאני שצוין במופע שאליו מתייחס register vB שווה לערך של register vA, כלומר:\nvB.field = vA</item>
		<item>קורא ערך משדה סטטי וממקם אותו במאגר vAA. האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>קורא ערך כפול/ארוך משדה סטטי וממקם אותו בזוג אוגרים vAA, vAA+1. האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>קורא הפניה לאובייקט משדה סטטי וממקם אותו במאגר vAA. האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>קורא ערך בוליאני משדה סטטי וממקם אותו במאגר vAA. האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>קורא ערך בתים (מספר שלם) משדה סטטי וממקם אותו במאגר vAA. האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>קורא ערך char משדה סטטי וממקם אותו ברישום vAA. האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>קורא ערך קצר (מספר שלם) משדה סטטי וממקם אותו במאגר vAA. האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>מציב את הערך מאוגר vAA בשדה (שדה סטטי). האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>מציב ערך כפול/ארוך מזוג אוגרים vAA, vAA+1 לתוך שדה (שדה סטטי). האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>ממקמת הפניה לאובייקט מאוגר vAA לתוך שדה (שדה סטטי). האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>ממקמת את הערך הבוליאני מאוגר vAA לתוך שדה (שדה סטטי). האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>מציב ערך בתים (מספר שלם) מאוגר vAA לתוך שדה (שדה סטטי). האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>ממקם את ערך ה-char מאוגר vAA בשדה סטטי. האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>מציב את הערך הקצר (המספר השלם) מאוגר vAA בשדה סטטי. האוגר המכיל את ההפניה למחלקה המכילה שדה זה אינו בשימוש.</item>
		<item>קורא (מריץ) שיטה וירטואלית עם פרמטרים. פרמטרים מסומנים בסוגרים מסולסלים. הפרמטר הראשון (register v2) מכיל הפניה למחלקה המכילה את המתודה שנקראה, הפרמטר השני (התוכן של register v3) מועבר למתודה שנקראה.</item>
		<item>קורא (מריץ) שיטה וירטואלית עם פרמטרים ישירות ממחלקת האב.</item>
		<item>קורא (מריץ) שיטה עם פרמטרים ללא הרשאות השיטה הוירטואלית.</item>
		<item>קורא (מריץ) שיטה סטטית עם פרמטרים. פרמטרים מסומנים בסוגרים מסולסלים. הפרמטר (התוכן של אוגר v3) מועבר למתודה שנקראה. המחלקה המכילה את השיטה הנקראת מסומנת אחרי הפלטה המתולתלת.</item>
		<item>קורא (מריץ) שיטת ממשק עם פרמטרים.</item>
		<item>קורא (מריץ) שיטה וירטואלית עם פרמטרים, אך יש להכיל את הפרמטרים ברגיסטרים עם מספרים לפי הסדר.</item>
		<item>קורא (מריץ) שיטה וירטואלית עם פרמטרים ישירות ממחלקת האב, אך הפרמטרים חייבים להיכלל ברגיסטרים עם מספרים עוקבים.</item>
		<item>קורא (מריץ) שיטה עם פרמטרים ללא הרשאות שיטה וירטואלית, אך הפרמטרים חייבים להיכלל באוגרים ממוספרים ברצף.</item>
		<item>קורא (מריץ) שיטה סטטית עם פרמטרים, אך הפרמטרים חייבים להיכלל ברגיסטרים עם מספרים עוקבים.</item>
		<item>קורא (מריץ) שיטת ממשק עם פרמטרים, אך הפרמטרים חייבים להיכלל באוגרים ממוספרים ברצף.</item>
		<item>מחשב vA = -vB עבור ערכים מסוג מספר שלם.</item>
		<item>מחשבת vA = ~vB עבור ערכים שלמים.\nvA = ~vB</item>
		<item>מחשב (vA, vA+1) = -(vB, vB+1) עבור ערכים מסוג ארוך (מספר שלם).</item>
		<item>מחשב (vA, vA+1) = ~(vB, vB+1) עבור ערכים מסוג ארוך (מספר שלם).</item>
		<item>מחשבת vA = -vB עבור ערכי ציפה.</item>
		<item>מחשב (vA, vA+1) = -(vB, vB+1) עבור ערכים כפולים (נקודה צפה).</item>
		<item>ממיר מספר שלם מ-vB ל-long ומאחסן אותו בזוג האוגר vA, vA+1.\n(vA, vA+1) = (ארוך) vB</item>
		<item>ממירה מספר שלם מ-vB ל-float ומאחסן אותו באוגר vA.\nvA = (צף) vB</item>
		<item>ממיר מספר שלם מ-vB לכפול (נקודה צפה) ומאחסן אותו בזוג אוגר vA, vA+1.\n(vA, vA+1) = (כפול) vB</item>
		<item>ממירה ערך ארוך (מספר שלם) מ- vB, vB+1 למספר שלם (מספר שלם) ומאחסן אותו באוגר vA.\nvA = (int) (vB, vB+1)</item>
		<item>ממירה ערך ארוך (מספר שלם) מ-vB, vB+1 ל-float (נקודה צפה) ומאחסן אותו באוגר vA.\nvA = (float) (vB, vB+1)</item>
		<item>ממיר ערך ארוך (מספר שלם) מ-vB, vB+1 לכפול (נקודה צפה) ומאחסן אותו בזוג אוגר vA, vA+1.\n(vA, vA+1) = (כפול) (vB, vB+1)</item>
		<item>ממירה ערך צף (נקודה צפה) מ-vB לערך שלם (מספר שלם) ומאחסן אותו באוגר vA.\nvA = (int)vB</item>
		<item>ממיר ערך צף (נקודה צפה) מ-vB לערך ארוך (מספר שלם) ומאחסן אותו בזוג האוגר vA, vA+1.\n(vA, vA+1) = (ארוך) vB</item>
		<item>ממיר ערך צף (נקודה צפה) מ-vB לערך כפול (נקודה צפה) ומאחסן אותו בזוג האוגר vA, vA+1.\n(vA, vA+1) = (כפול) vB</item>
		<item>ממירה ערך כפול (נקודה צפה) מ-vB, vB+1 לערך שלם (מספר שלם) ומאחסן אותו באוגר vA.\nvA = (int) (vB, vB+1)</item>
		<item>ממירה ערך כפול (נקודה צפה) מ-vB, vB+1 לערך ארוך (מספר שלם) ומאחסן אותו בזוג אוגר vA, vA+1.\n(vA, vA+1) = (ארוך) (vB, vB+1)</item>
		<item>ממיר ערך כפול (נקודה צפה) מ-vB, vB+1 לערך צף (נקודה צפה) ומאחסן אותו באוגר vA.\nvA = (float) (vB, vB+1)</item>
		<item>ממירה ערך מספר שלם מ-vB לערך בתים ומאחסן אותו באוגר vA.\nvA = (בייט) vB</item>
		<item>ממירה ערך שלם מ-vB לערך char ומאחסן אותו באוגר vA.\nvA = (char)vB</item>
		<item>ממירה ערך שלם מ-vB לערך קצר ומאחסן אותו באוגר vA.\nvA = (קצר) vB</item>
		<item>מחשב vBB + vCC ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB + vCC</item>
		<item>מחשב vBB - vCC ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB - vCC</item>
		<item>מחשב את vBB * vCC ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB * vCC</item>
		<item>מחשב את vBB / vCC ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB / vCC</item>
		<item>מחשב את vBB % vCC ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB % vCC</item>
		<item>מחשב vBB &amp; vCC (לוגי AND) ומאחסן את התוצאה ב-vAA register. כל הערכים הם מספר שלם.\nvAA = vBB &amp; vCC</item>
		<item>מחשב vBB | vCC (או לוגי) ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB | vCC</item>
		<item>מחשב את vBB ^ vCC (בלעדי OR) ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB ^ vCC</item>
		<item>מעביר את vBB שנשאר לפי מספר הביטים שצוין על ידי vCC ומאחסן את התוצאה באוגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB &lt;&lt; vCC</item>
		<item>מעביר את vBB ימינה במספר הסיביות שצוין על ידי vCC ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB >> vCC</item>
		<item>מעביר את vBB מבלי לשמר סימן ימינה במספר הסיביות שצוין על ידי vCC, ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB >>> vCC</item>
		<item>מחשב (vBB, vBB+1) + (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) + (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) - (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) - (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) * (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) * (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) / (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) / (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) % (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) % (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) &amp; (vCC, vCC+1) (לוגי AND) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) &amp; (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) | (vCC, vCC+1) (או לוגי) ומאחסן את התוצאה בזוג אוגרים vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) | (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) ^ (vCC, vCC+1) (בלעדי AND) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) ^ (vCC, vCC+1)</item>
		<item>מעביר את vBB, vBB+1 שמאלה במספר הסיביות שצוין על ידי vCC, ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) &lt;&lt; vCC</item>
		<item>מעביר את vBB, vBB+1 ימינה במספר הסיביות שצוין על ידי vCC, ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) >> vCC</item>
		<item>מעביר את vBB, vBB+1 ימינה מבלי לשמר את הסימן במספר הסיביות שצוין על ידי vCC, ומאחסן את התוצאה בזוג אוגרים vAA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vAA, vAA+1) = (vBB, vBB+1) >>> vCC</item>
		<item>מחשב vBB + vCC ומאחסן את התוצאה במאגר vAA. כל הערכים צפים.\nvAA = vBB + vCC</item>
		<item>מחשב vBB - vCC ומאחסן את התוצאה במאגר vAA. כל הערכים צפים.\nvAA = vBB - vCC</item>
		<item>מחשב את vBB * vCC ומאחסן את התוצאה במאגר vAA. כל הערכים צפים.\nvAA = vBB * vCC</item>
		<item>מחשב את vBB / vCC ומאחסן את התוצאה במאגר vAA. כל הערכים צפים.\nvAA = vBB / vCC</item>
		<item>מחשב את vBB % vCC ומאחסן את התוצאה במאגר vAA. כל הערכים צפים.\nvAA = vBB % vCC</item>
		<item>מחשב (vBB, vBB+1) + (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים כפולים (נקודה צפה).\n(vAA, vAA+1) = (vBB, vBB+1) + (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) - (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים כפולים (נקודה צפה).\n(vAA, vAA+1) = (vBB, vBB+1) - (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) * (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים כפולים (נקודה צפה).\n(vAA, vAA+1) = (vBB, vBB+1) * (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) / (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים כפולים (נקודה צפה).\n(vAA, vAA+1) = (vBB, vBB+1) / (vCC, vCC+1)</item>
		<item>מחשב (vBB, vBB+1) % (vCC, vCC+1) ומאחסן את התוצאה בזוג האוגר vAA, vAA+1. כל הערכים כפולים (נקודה צפה).\n(vAA, vAA+1) = (vBB, vBB+1) % (vCC, vCC+1)</item>
		<item>מחשב vA + vB ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA + vB</item>
		<item>מחשב את vA - vB ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA - vB</item>
		<item>מחשב את vA * vB ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA * vB</item>
		<item>מחשב את vA / vB ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA / vB</item>
		<item>מחשב את vA % vB ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA % vB</item>
		<item>מחשב את vA &amp; vB (ולוגי AND) ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA &amp; vB</item>
		<item>מחשב vA | vB (או לוגי) ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA | vB</item>
		<item>מחשב vA ^ vB (בלעדי OR) ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA ^ vB</item>
		<item>מעביר את vA שמאלה במספר הסיביות שצוין על ידי vB ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA &lt;&lt; vB</item>
		<item>מעביר את vA ימינה במספר הסיביות שצוין על ידי vB ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA >> vB</item>
		<item>מעביר את vA מבלי לשמר את הסימן שלו ימינה במספר הסיביות שצוין על ידי vB, ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vA >>> vB</item>
		<item>מחשב (vA, vA+1) + (vB, vB+1) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) + (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) - (vB, vB+1) ומאחסן את התוצאה בזוג אוגרים vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) - (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) * (vB, vB+1) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) * (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) / (vB, vB+1) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) / (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) % (vB, vB+1) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) % (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) &amp; (vB, vB+1) (ולוגי AND) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) &amp; (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) | (vB, vB+1) (או לוגי) ומאחסן את התוצאה בזוג אוגרים vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) | (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) &amp; (vB, vB+1) (בלעדי OR) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) ^ (vB, vB+1)</item>
		<item>מעביר את vA, vA+1 שמאלה במספר הסיביות שצוין על ידי vB, ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) &lt;&lt; vB</item>
		<item>מעביר את vA, vA+1 ימינה במספר הסיביות שצוין על ידי vB, ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) >> vB</item>
		<item>מעביר את vA, vA+1 ימינה מבלי לשמר את הסימן במספר הספרות שצוין ב-vB, ומאחסן את התוצאה בזוג אוגרים vA, vA+1. כל הערכים ארוכים (מספר שלם).\n(vA, vA+1) = (vA, vA+1) >>> vB</item>
		<item>מחשב vA + vB ומאחסן את התוצאה במאגר vA. כל הערכים צפים.\nvA = vA + vB</item>
		<item>מחשב את vA - vB ומאחסן את התוצאה במאגר vA. כל הערכים צפים.\nvA = vA - vB</item>
		<item>מחשב את vA * vB ומאחסן את התוצאה במאגר vA. כל הערכים צפים.\nvA = vA * vB</item>
		<item>מחשב את vA / vB ומאחסן את התוצאה במאגר vA. כל הערכים צפים.\nvA = vA / vB</item>
		<item>מחשב את vA % vB ומאחסן את התוצאה במאגר vA. כל הערכים צפים.\nvA = vA % vB</item>
		<item>מחשב (vA, vA+1) + (vB, vB+1) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים כפולים (נקודה צפה).\n(vA, vA+1) = (vA, vA+1) + (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) - (vB, vB+1) ומאחסן את התוצאה בזוג אוגרים vA, vA+1. כל הערכים כפולים (נקודה צפה).\n(vA, vA+1) = (vA, vA+1) - (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) * (vB, vB+1) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים כפולים (נקודה צפה).\n(vA, vA+1) = (vA, vA+1) * (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) / (vB, vB+1) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים כפולים (נקודה צפה).\n(vA, vA+1) = (vA, vA+1) / (vB, vB+1)</item>
		<item>מחשב (vA, vA+1) % (vB, vB+1) ומאחסן את התוצאה בזוג האוגר vA, vA+1. כל הערכים כפולים (נקודה צפה).\n(vA, vA+1) = (vA, vA+1) % (vB, vB+1)</item>
		<item>מחשב vB + 0xFFFF ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vB + 0xFFFF</item>
		<item>מחשב 0xFFFF - vB ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = 0xFFFF - vB</item>
		<item>מחשב vB * 0xFFFF ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vB * 0xFFFF</item>
		<item>מחשב vB / 0xFFFF ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vB / 0xFFFF</item>
		<item>מחשב את vB % 0xFFFF ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vB % 0xFFFF</item>
		<item>מחשב vB &amp; 0xFFFF (ולוגי AND) ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vB &amp; 0xFFFF</item>
		<item>מחשב vB | 0xFFFF (או לוגי) ומאחסן את התוצאה באוגר vA. כל הערכים הם מספר שלם.\nvA = vB | 0xFFFF</item>
		<item>מחשב את vB ^ 0xFFFF (בלעדי OR) ומאחסן את התוצאה במאגר vA. כל הערכים הם מספר שלם.\nvA = vB ^ 0xFFFF</item>
		<item>מחשב vBB + 0xFF ומאחסן את התוצאה באוגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB + 0xFF</item>
		<item>מחשב 0xFF - vBB ומאחסן את התוצאה באוגר vAA. כל הערכים הם מספר שלם.\nvAA = 0xFF - vBB</item>
		<item>מחשב vBB * 0xFF ומאחסן את התוצאה באוגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB * 0xFF</item>
		<item>מחשב vBB / 0xFF ומאחסן את התוצאה באוגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB / 0xFF</item>
		<item>מחשב את vBB % 0xFF ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB % 0xFF</item>
		<item>מחשב את vBB &amp; 0xFF (ולוגי AND) ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB &amp; 0xFF</item>
		<item>מחשב vBB | 0xFF (או לוגי) ומאחסן את התוצאה באוגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB | 0xFF</item>
		<item>מחשב את vBB ^ 0xFF (בלעדי OR) ומאחסן את התוצאה במאגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB ^ 0xFF</item>
		<item>מעביר את vBB שנשאר לפי מספר הביטים שצוין על ידי 0xFF ומאחסן את התוצאה באוגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB &lt;&lt; 0xFF</item>
		<item>מעביר את vBB ימינה במספר הסיביות שצוין ב-0xFF ומאחסן את התוצאה באוגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB >> 0xFF</item>
		<item>מעביר באופן איתות את vBB ימינה במספר הסיביות שצוין ב-0xFF ומאחסן את התוצאה באוגר vAA. כל הערכים הם מספר שלם.\nvAA = vBB >>> 0xFF</item>
		<item>קורא (מריץ) שיטת חתימה פולימורפית עם פרמטרים. קיים בקבצי Dex מאז גרסה 038.</item>
		<item>קורא (מריץ) שיטת חתימה פולימורפית עם פרמטרים, אך הפרמטרים חייבים להיכלל באוגרים ממוספרים ברצף. קיים בקבצי Dex מאז גרסה 038.</item>
		<item>מאפשר (מתחיל) קריאה לאתר עם פרמטרים. קיים בקבצי Dex מאז גרסה 038.</item>
		<item>מאפשר (מתחיל) להתקשר לאתר עם פרמטרים, אך הפרמטרים חייבים להיות מוכלים ברגיסטרים עם מספרים לפי הסדר. קיים בקבצי Dex מאז גרסה 038.</item>
		<item>מציב הפניה לנקודת אחיזה של שיטה באוגר vAA. קיים בקבצי Dex מאז גרסה 039.</item>
		<item>מציב הפניה לאב-טיפוס השיטה במאגר vAA. קיים בקבצי Dex מאז גרסה 039.</item>
	</string-array>
</resources>